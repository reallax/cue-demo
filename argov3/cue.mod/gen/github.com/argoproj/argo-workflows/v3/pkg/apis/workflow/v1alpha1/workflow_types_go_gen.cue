// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/argoproj/argo-workflows/v3/pkg/apis/workflow/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	apiv1 "k8s.io/api/core/v1"
	policyv1 "k8s.io/api/policy/v1"
	"k8s.io/apimachinery/pkg/util/intstr"
)

// TemplateType is the type of a template
#TemplateType: string // #enumTemplateType

#enumTemplateType:
	#TemplateTypeContainer |
	#TemplateTypeContainerSet |
	#TemplateTypeSteps |
	#TemplateTypeScript |
	#TemplateTypeResource |
	#TemplateTypeDAG |
	#TemplateTypeSuspend |
	#TemplateTypeData |
	#TemplateTypeHTTP |
	#TemplateTypePlugin |
	#TemplateTypeUnknown

#TemplateTypeContainer:    #TemplateType & "Container"
#TemplateTypeContainerSet: #TemplateType & "ContainerSet"
#TemplateTypeSteps:        #TemplateType & "Steps"
#TemplateTypeScript:       #TemplateType & "Script"
#TemplateTypeResource:     #TemplateType & "Resource"
#TemplateTypeDAG:          #TemplateType & "DAG"
#TemplateTypeSuspend:      #TemplateType & "Suspend"
#TemplateTypeData:         #TemplateType & "Data"
#TemplateTypeHTTP:         #TemplateType & "HTTP"
#TemplateTypePlugin:       #TemplateType & "Plugin"
#TemplateTypeUnknown:      #TemplateType & "Unknown"

// NodePhase is a label for the condition of a node at the current time.
#NodePhase: string // #enumNodePhase

#enumNodePhase:
	#NodePending |
	#NodeRunning |
	#NodeSucceeded |
	#NodeSkipped |
	#NodeFailed |
	#NodeError |
	#NodeOmitted

// Node is waiting to run
#NodePending: #NodePhase & "Pending"

// Node is running
#NodeRunning: #NodePhase & "Running"

// Node finished with no errors
#NodeSucceeded: #NodePhase & "Succeeded"

// Node was skipped
#NodeSkipped: #NodePhase & "Skipped"

// Node or child of node exited with non-0 code
#NodeFailed: #NodePhase & "Failed"

// Node had an error other than a non 0 exit code
#NodeError: #NodePhase & "Error"

// Node was omitted because its `depends` condition was not met (only relevant in DAGs)
#NodeOmitted: #NodePhase & "Omitted"

// NodeType is the type of a node
#NodeType: string // #enumNodeType

#enumNodeType:
	#NodeTypePod |
	#NodeTypeContainer |
	#NodeTypeSteps |
	#NodeTypeStepGroup |
	#NodeTypeDAG |
	#NodeTypeTaskGroup |
	#NodeTypeRetry |
	#NodeTypeSkipped |
	#NodeTypeSuspend |
	#NodeTypeHTTP |
	#NodeTypePlugin

#NodeTypePod:       #NodeType & "Pod"
#NodeTypeContainer: #NodeType & "Container"
#NodeTypeSteps:     #NodeType & "Steps"
#NodeTypeStepGroup: #NodeType & "StepGroup"
#NodeTypeDAG:       #NodeType & "DAG"
#NodeTypeTaskGroup: #NodeType & "TaskGroup"
#NodeTypeRetry:     #NodeType & "Retry"
#NodeTypeSkipped:   #NodeType & "Skipped"
#NodeTypeSuspend:   #NodeType & "Suspend"
#NodeTypeHTTP:      #NodeType & "HTTP"
#NodeTypePlugin:    #NodeType & "Plugin"

// ArtifactGCStrategy is the strategy when to delete artifacts for GC.
#ArtifactGCStrategy: string // #enumArtifactGCStrategy

#enumArtifactGCStrategy:
	#ArtifactGCOnWorkflowCompletion |
	#ArtifactGCOnWorkflowDeletion |
	#ArtifactGCNever |
	#ArtifactGCStrategyUndefined

#ArtifactGCOnWorkflowCompletion: #ArtifactGCStrategy & "OnWorkflowCompletion"
#ArtifactGCOnWorkflowDeletion:   #ArtifactGCStrategy & "OnWorkflowDeletion"
#ArtifactGCNever:                #ArtifactGCStrategy & "Never"
#ArtifactGCStrategyUndefined:    #ArtifactGCStrategy & ""

// PodGCStrategy is the strategy when to delete completed pods for GC.
#PodGCStrategy: string // #enumPodGCStrategy

#enumPodGCStrategy:
	#PodGCOnPodNone |
	#PodGCOnPodCompletion |
	#PodGCOnPodSuccess |
	#PodGCOnWorkflowCompletion |
	#PodGCOnWorkflowSuccess

#PodGCOnPodNone:            #PodGCStrategy & ""
#PodGCOnPodCompletion:      #PodGCStrategy & "OnPodCompletion"
#PodGCOnPodSuccess:         #PodGCStrategy & "OnPodSuccess"
#PodGCOnWorkflowCompletion: #PodGCStrategy & "OnWorkflowCompletion"
#PodGCOnWorkflowSuccess:    #PodGCStrategy & "OnWorkflowSuccess"

// VolumeClaimGCStrategy is the strategy to use when deleting volumes from completed workflows
#VolumeClaimGCStrategy: string // #enumVolumeClaimGCStrategy

#enumVolumeClaimGCStrategy:
	#VolumeClaimGCOnCompletion |
	#VolumeClaimGCOnSuccess

#VolumeClaimGCOnCompletion: #VolumeClaimGCStrategy & "OnWorkflowCompletion"
#VolumeClaimGCOnSuccess:    #VolumeClaimGCStrategy & "OnWorkflowSuccess"

// Workflow is the definition of a workflow resource
// +genclient
// +genclient:noStatus
// +kubebuilder:resource:shortName=wf
// +kubebuilder:printcolumn:name="Status",type="string",JSONPath=".status.phase",description="Status of the workflow"
// +kubebuilder:printcolumn:name="Age",type="date",format="date-time",JSONPath=".status.startedAt",description="When the workflow was started"
// +kubebuilder:printcolumn:name="Message",type="string",JSONPath=".status.message",description="Human readable message indicating details about why the workflow is in this condition."
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#Workflow: {
	metav1.#TypeMeta
	metadata: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:     #WorkflowSpec      @go(Spec) @protobuf(2,bytes,opt,name=spec )
	status?:  #WorkflowStatus    @go(Status) @protobuf(3,bytes,opt)
}

// Workflows is a sort interface which sorts running jobs earlier before considering FinishedAt
#Workflows: [...#Workflow]

// WorkflowList is list of Workflow resources
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#WorkflowList: {
	metav1.#TypeMeta
	metadata: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items:    #Workflows       @go(Items) @protobuf(2,bytes,opt)
}

// TTLStrategy is the strategy for the time to live depending on if the workflow succeeded or failed
#TTLStrategy: {
	// SecondsAfterCompletion is the number of seconds to live after completion
	secondsAfterCompletion?: null | int32 @go(SecondsAfterCompletion,*int32) @protobuf(1,bytes,opt)

	// SecondsAfterSuccess is the number of seconds to live after success
	secondsAfterSuccess?: null | int32 @go(SecondsAfterSuccess,*int32) @protobuf(2,bytes,opt)

	// SecondsAfterFailure is the number of seconds to live after failure
	secondsAfterFailure?: null | int32 @go(SecondsAfterFailure,*int32) @protobuf(3,bytes,opt)
}

// WorkflowSpec is the specification of a Workflow.
#WorkflowSpec: {
	// Templates is a list of workflow templates used in a workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	templates?: [...#Template] @go(Templates,[]Template) @protobuf(1,bytes,opt)

	// Entrypoint is a template reference to the starting point of the workflow.
	entrypoint?: string @go(Entrypoint) @protobuf(2,bytes,opt)

	// Arguments contain the parameters and artifacts sent to the workflow entrypoint
	// Parameters are referencable globally using the 'workflow' variable prefix.
	// e.g. {{workflow.parameters.myparam}}
	arguments?: #Arguments @go(Arguments) @protobuf(3,bytes,opt)

	// ServiceAccountName is the name of the ServiceAccount to run all pods of the workflow as.
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(4,bytes,opt)

	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
	// ServiceAccountName of ExecutorConfig must be specified if this value is false.
	automountServiceAccountToken?: null | bool @go(AutomountServiceAccountToken,*bool) @protobuf(28,varint,opt)

	// Executor holds configurations of executor containers of the workflow.
	executor?: null | #ExecutorConfig @go(Executor,*ExecutorConfig) @protobuf(29,bytes,opt)

	// Volumes is a list of volumes that can be mounted by containers in a workflow.
	// +patchStrategy=merge
	// +patchMergeKey=name
	volumes?: [...apiv1.#Volume] @go(Volumes,[]apiv1.Volume) @protobuf(5,bytes,opt)

	// VolumeClaimTemplates is a list of claims that containers are allowed to reference.
	// The Workflow controller will create the claims at the beginning of the workflow
	// and delete the claims upon completion of the workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	volumeClaimTemplates?: [...apiv1.#PersistentVolumeClaim] @go(VolumeClaimTemplates,[]apiv1.PersistentVolumeClaim) @protobuf(6,bytes,opt)

	// Parallelism limits the max total parallel pods that can execute at the same time in a workflow
	parallelism?: null | int64 @go(Parallelism,*int64) @protobuf(7,bytes,opt)

	// ArtifactRepositoryRef specifies the configMap name and key containing the artifact repository config.
	artifactRepositoryRef?: null | #ArtifactRepositoryRef @go(ArtifactRepositoryRef,*ArtifactRepositoryRef) @protobuf(8,bytes,opt)

	// Suspend will suspend the workflow and prevent execution of any future steps in the workflow
	suspend?: null | bool @go(Suspend,*bool) @protobuf(9,bytes,opt)

	// NodeSelector is a selector which will result in all pods of the workflow
	// to be scheduled on the selected node(s). This is able to be overridden by
	// a nodeSelector specified in the template.
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string) @protobuf(10,bytes,opt)

	// Affinity sets the scheduling constraints for all pods in the workflow.
	// Can be overridden by an affinity specified in the template
	affinity?: null | apiv1.#Affinity @go(Affinity,*apiv1.Affinity) @protobuf(11,bytes,opt)

	// Tolerations to apply to workflow pods.
	// +patchStrategy=merge
	// +patchMergeKey=key
	tolerations?: [...apiv1.#Toleration] @go(Tolerations,[]apiv1.Toleration) @protobuf(12,bytes,opt)

	// ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images
	// in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets
	// can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet.
	// More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
	// +patchStrategy=merge
	// +patchMergeKey=name
	imagePullSecrets?: [...apiv1.#LocalObjectReference] @go(ImagePullSecrets,[]apiv1.LocalObjectReference) @protobuf(13,bytes,opt)

	// Host networking requested for this workflow pod. Default to false.
	hostNetwork?: null | bool @go(HostNetwork,*bool) @protobuf(14,bytes,opt)

	// Set DNS policy for the pod.
	// Defaults to "ClusterFirst".
	// Valid values are 'ClusterFirstWithHostNet', 'ClusterFirst', 'Default' or 'None'.
	// DNS parameters given in DNSConfig will be merged with the policy selected with DNSPolicy.
	// To have DNS options set along with hostNetwork, you have to specify DNS policy
	// explicitly to 'ClusterFirstWithHostNet'.
	dnsPolicy?: null | apiv1.#DNSPolicy @go(DNSPolicy,*apiv1.DNSPolicy) @protobuf(15,bytes,opt)

	// PodDNSConfig defines the DNS parameters of a pod in addition to
	// those generated from DNSPolicy.
	dnsConfig?: null | apiv1.#PodDNSConfig @go(DNSConfig,*apiv1.PodDNSConfig) @protobuf(16,bytes,opt)

	// OnExit is a template reference which is invoked at the end of the
	// workflow, irrespective of the success, failure, or error of the
	// primary workflow.
	onExit?: string @go(OnExit) @protobuf(17,bytes,opt)

	// TTLStrategy limits the lifetime of a Workflow that has finished execution depending on if it
	// Succeeded or Failed. If this struct is set, once the Workflow finishes, it will be
	// deleted after the time to live expires. If this field is unset,
	// the controller config map will hold the default values.
	ttlStrategy?: null | #TTLStrategy @go(TTLStrategy,*TTLStrategy) @protobuf(30,bytes,opt)

	// Optional duration in seconds relative to the workflow start time which the workflow is
	// allowed to run before the controller terminates the workflow. A value of zero is used to
	// terminate a Running workflow
	activeDeadlineSeconds?: null | int64 @go(ActiveDeadlineSeconds,*int64) @protobuf(19,bytes,opt)

	// Priority is used if controller is configured to process limited number of workflows in parallel. Workflows with higher priority are processed first.
	priority?: null | int32 @go(Priority,*int32) @protobuf(20,bytes,opt)

	// Set scheduler name for all pods.
	// Will be overridden if container/script template's scheduler name is set.
	// Default scheduler will be used if neither specified.
	// +optional
	schedulerName?: string @go(SchedulerName) @protobuf(21,bytes,opt)

	// PodGC describes the strategy to use when deleting completed pods
	podGC?: null | #PodGC @go(PodGC,*PodGC) @protobuf(22,bytes,opt)

	// PriorityClassName to apply to workflow pods.
	podPriorityClassName?: string @go(PodPriorityClassName) @protobuf(23,bytes,opt)

	// Priority to apply to workflow pods.
	// DEPRECATED: Use PodPriorityClassName instead.
	podPriority?: null | int32 @go(PodPriority,*int32) @protobuf(24,bytes,opt)

	// +patchStrategy=merge
	// +patchMergeKey=ip
	hostAliases?: [...apiv1.#HostAlias] @go(HostAliases,[]apiv1.HostAlias) @protobuf(25,bytes,opt)

	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	securityContext?: null | apiv1.#PodSecurityContext @go(SecurityContext,*apiv1.PodSecurityContext) @protobuf(26,bytes,opt)

	// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
	// container fields which are not strings (e.g. resource limits).
	podSpecPatch?: string @go(PodSpecPatch) @protobuf(27,bytes,opt)

	// PodDisruptionBudget holds the number of concurrent disruptions that you allow for Workflow's Pods.
	// Controller will automatically add the selector with workflow name, if selector is empty.
	// Optional: Defaults to empty.
	// +optional
	podDisruptionBudget?: null | policyv1.#PodDisruptionBudgetSpec @go(PodDisruptionBudget,*policyv1.PodDisruptionBudgetSpec) @protobuf(31,bytes,opt)

	// Metrics are a list of metrics emitted from this Workflow
	metrics?: null | #Metrics @go(Metrics,*Metrics) @protobuf(32,bytes,opt)

	// Shutdown will shutdown the workflow according to its ShutdownStrategy
	shutdown?: #ShutdownStrategy @go(Shutdown) @protobuf(33,bytes,opt,casttype=ShutdownStrategy)

	// WorkflowTemplateRef holds a reference to a WorkflowTemplate for execution
	workflowTemplateRef?: null | #WorkflowTemplateRef @go(WorkflowTemplateRef,*WorkflowTemplateRef) @protobuf(34,bytes,opt)

	// Synchronization holds synchronization lock configuration for this Workflow
	synchronization?: null | #Synchronization @go(Synchronization,*Synchronization) @protobuf(35,bytes,opt,casttype=Synchronization)

	// VolumeClaimGC describes the strategy to use when deleting volumes from completed workflows
	volumeClaimGC?: null | #VolumeClaimGC @go(VolumeClaimGC,*VolumeClaimGC) @protobuf(36,bytes,opt,casttype=VolumeClaimGC)

	// RetryStrategy for all templates in the workflow.
	retryStrategy?: null | #RetryStrategy @go(RetryStrategy,*RetryStrategy) @protobuf(37,bytes,opt)

	// PodMetadata defines additional metadata that should be applied to workflow pods
	podMetadata?: null | #Metadata @go(PodMetadata,*Metadata) @protobuf(38,bytes,opt)

	// TemplateDefaults holds default template values that will apply to all templates in the Workflow, unless overridden on the template-level
	templateDefaults?: null | #Template @go(TemplateDefaults,*Template) @protobuf(39,bytes,opt)

	// ArchiveLogs indicates if the container logs should be archived
	archiveLogs?: null | bool @go(ArchiveLogs,*bool) @protobuf(40,varint,opt)

	// Hooks holds the lifecycle hook which is invoked at lifecycle of
	// step, irrespective of the success, failure, or error status of the primary step
	hooks?: #LifecycleHooks @go(Hooks) @protobuf(41,bytes,opt)

	// WorkflowMetadata contains some metadata of the workflow to refer to
	workflowMetadata?: null | #WorkflowMetadata @go(WorkflowMetadata,*WorkflowMetadata) @protobuf(42,bytes,opt)

	// ArtifactGC describes the strategy to use when deleting artifacts from completed or deleted workflows (applies to all output Artifacts
	// unless Artifact.ArtifactGC is specified, which overrides this)
	artifactGC?: null | #WorkflowLevelArtifactGC @go(ArtifactGC,*WorkflowLevelArtifactGC) @protobuf(43,bytes,opt)
}

#LabelValueFrom: {
	expression: string @go(Expression) @protobuf(1,bytes,opt)
}

#WorkflowMetadata: {
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(1,bytes,rep)
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(2,bytes,rep)
	labelsFrom?: {[string]: #LabelValueFrom} @go(LabelsFrom,map[string]LabelValueFrom) @protobuf(3,bytes,rep)
}

#ShutdownStrategy: string // #enumShutdownStrategy

#enumShutdownStrategy:
	#ShutdownStrategyTerminate |
	#ShutdownStrategyStop |
	#ShutdownStrategyNone

#ShutdownStrategyTerminate: #ShutdownStrategy & "Terminate"
#ShutdownStrategyStop:      #ShutdownStrategy & "Stop"
#ShutdownStrategyNone:      #ShutdownStrategy & ""

// +kubebuilder:validation:Type=array
#ParallelSteps: _

// Template is a reusable and composable unit of execution in a workflow
#Template: {
	// Name is the name of the template
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Inputs describe what inputs parameters and artifacts are supplied to this template
	inputs?: #Inputs @go(Inputs) @protobuf(5,bytes,opt)

	// Outputs describe the parameters and artifacts that this template produces
	outputs?: #Outputs @go(Outputs) @protobuf(6,bytes,opt)

	// NodeSelector is a selector to schedule this step of the workflow to be
	// run on the selected node(s). Overrides the selector set at the workflow level.
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string) @protobuf(7,bytes,opt)

	// Affinity sets the pod's scheduling constraints
	// Overrides the affinity set at the workflow level (if any)
	affinity?: null | apiv1.#Affinity @go(Affinity,*apiv1.Affinity) @protobuf(8,bytes,opt)

	// Metdata sets the pods's metadata, i.e. annotations and labels
	metadata?: #Metadata @go(Metadata) @protobuf(9,bytes,opt)

	// Daemon will allow a workflow to proceed to the next step so long as the container reaches readiness
	daemon?: null | bool @go(Daemon,*bool) @protobuf(10,bytes,opt)

	// Steps define a series of sequential/parallel workflow steps
	steps?: [...#ParallelSteps] @go(Steps,[]ParallelSteps) @protobuf(11,bytes,opt)

	// Container is the main container image to run in the pod
	container?: null | apiv1.#Container @go(Container,*apiv1.Container) @protobuf(12,bytes,opt)

	// ContainerSet groups multiple containers within a single pod.
	containerSet?: null | #ContainerSetTemplate @go(ContainerSet,*ContainerSetTemplate) @protobuf(40,bytes,opt)

	// Script runs a portion of code against an interpreter
	script?: null | #ScriptTemplate @go(Script,*ScriptTemplate) @protobuf(13,bytes,opt)

	// Resource template subtype which can run k8s resources
	resource?: null | #ResourceTemplate @go(Resource,*ResourceTemplate) @protobuf(14,bytes,opt)

	// DAG template subtype which runs a DAG
	dag?: null | #DAGTemplate @go(DAG,*DAGTemplate) @protobuf(15,bytes,opt)

	// Suspend template subtype which can suspend a workflow when reaching the step
	suspend?: null | #SuspendTemplate @go(Suspend,*SuspendTemplate) @protobuf(16,bytes,opt)

	// Data is a data template
	data?: null | #Data @go(Data,*Data) @protobuf(39,bytes,opt)

	// HTTP makes a HTTP request
	http?: null | #HTTP @go(HTTP,*HTTP) @protobuf(42,bytes,opt)

	// Plugin is a plugin template
	plugin?: null | #Plugin @go(Plugin,*Plugin) @protobuf(43,bytes,opt)

	// Volumes is a list of volumes that can be mounted by containers in a template.
	// +patchStrategy=merge
	// +patchMergeKey=name
	volumes?: [...apiv1.#Volume] @go(Volumes,[]apiv1.Volume) @protobuf(17,bytes,opt)

	// InitContainers is a list of containers which run before the main container.
	// +patchStrategy=merge
	// +patchMergeKey=name
	initContainers?: [...#UserContainer] @go(InitContainers,[]UserContainer) @protobuf(18,bytes,opt)

	// Sidecars is a list of containers which run alongside the main container
	// Sidecars are automatically killed when the main container completes
	// +patchStrategy=merge
	// +patchMergeKey=name
	sidecars?: [...#UserContainer] @go(Sidecars,[]UserContainer) @protobuf(19,bytes,opt)

	// Location in which all files related to the step will be stored (logs, artifacts, etc...).
	// Can be overridden by individual items in Outputs. If omitted, will use the default
	// artifact repository location configured in the controller, appended with the
	// <workflowname>/<nodename> in the key.
	archiveLocation?: null | #ArtifactLocation @go(ArchiveLocation,*ArtifactLocation) @protobuf(20,bytes,opt)

	// Optional duration in seconds relative to the StartTime that the pod may be active on a node
	// before the system actively tries to terminate the pod; value must be positive integer
	// This field is only applicable to container and script templates.
	activeDeadlineSeconds?: null | intstr.#IntOrString @go(ActiveDeadlineSeconds,*intstr.IntOrString) @protobuf(21,bytes,opt)

	// RetryStrategy describes how to retry a template when it fails
	retryStrategy?: null | #RetryStrategy @go(RetryStrategy,*RetryStrategy) @protobuf(22,bytes,opt)

	// Parallelism limits the max total parallel pods that can execute at the same time within the
	// boundaries of this template invocation. If additional steps/dag templates are invoked, the
	// pods created by those templates will not be counted towards this total.
	parallelism?: null | int64 @go(Parallelism,*int64) @protobuf(23,bytes,opt)

	// FailFast, if specified, will fail this template if any of its child pods has failed. This is useful for when this
	// template is expanded with `withItems`, etc.
	failFast?: null | bool @go(FailFast,*bool) @protobuf(41,varint,opt)

	// Tolerations to apply to workflow pods.
	// +patchStrategy=merge
	// +patchMergeKey=key
	tolerations?: [...apiv1.#Toleration] @go(Tolerations,[]apiv1.Toleration) @protobuf(24,bytes,opt)

	// If specified, the pod will be dispatched by specified scheduler.
	// Or it will be dispatched by workflow scope scheduler if specified.
	// If neither specified, the pod will be dispatched by default scheduler.
	// +optional
	schedulerName?: string @go(SchedulerName) @protobuf(25,bytes,opt)

	// PriorityClassName to apply to workflow pods.
	priorityClassName?: string @go(PriorityClassName) @protobuf(26,bytes,opt)

	// Priority to apply to workflow pods.
	priority?: null | int32 @go(Priority,*int32) @protobuf(27,bytes,opt)

	// ServiceAccountName to apply to workflow pods
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(28,bytes,opt)

	// AutomountServiceAccountToken indicates whether a service account token should be automatically mounted in pods.
	// ServiceAccountName of ExecutorConfig must be specified if this value is false.
	automountServiceAccountToken?: null | bool @go(AutomountServiceAccountToken,*bool) @protobuf(32,varint,opt)

	// Executor holds configurations of the executor container.
	executor?: null | #ExecutorConfig @go(Executor,*ExecutorConfig) @protobuf(33,bytes,opt)

	// HostAliases is an optional list of hosts and IPs that will be injected into the pod spec
	// +patchStrategy=merge
	// +patchMergeKey=ip
	hostAliases?: [...apiv1.#HostAlias] @go(HostAliases,[]apiv1.HostAlias) @protobuf(29,bytes,opt)

	// SecurityContext holds pod-level security attributes and common container settings.
	// Optional: Defaults to empty.  See type description for default values of each field.
	// +optional
	securityContext?: null | apiv1.#PodSecurityContext @go(SecurityContext,*apiv1.PodSecurityContext) @protobuf(30,bytes,opt)

	// PodSpecPatch holds strategic merge patch to apply against the pod spec. Allows parameterization of
	// container fields which are not strings (e.g. resource limits).
	podSpecPatch?: string @go(PodSpecPatch) @protobuf(31,bytes,opt)

	// Metrics are a list of metrics emitted from this template
	metrics?: null | #Metrics @go(Metrics,*Metrics) @protobuf(35,bytes,opt)

	// Synchronization holds synchronization lock configuration for this template
	synchronization?: null | #Synchronization @go(Synchronization,*Synchronization) @protobuf(36,bytes,opt,casttype=Synchronization)

	// Memoize allows templates to use outputs generated from already executed templates
	memoize?: null | #Memoize @go(Memoize,*Memoize) @protobuf(37,bytes,opt)

	// Timeout allows to set the total node execution timeout duration counting from the node's start time.
	// This duration also includes time in which the node spends in Pending state. This duration may not be applied to Step or DAG templates.
	timeout?: string @go(Timeout) @protobuf(38,bytes,opt)
}

#Artifacts: [...#Artifact]

// Inputs are the mechanism for passing parameters, artifacts, volumes from one template to another
#Inputs: {
	// Parameters are a list of parameters passed as inputs
	// +patchStrategy=merge
	// +patchMergeKey=name
	parameters?: [...#Parameter] @go(Parameters,[]Parameter) @protobuf(1,bytes,opt)

	// Artifact are a list of artifacts passed as inputs
	// +patchStrategy=merge
	// +patchMergeKey=name
	artifacts?: #Artifacts @go(Artifacts) @protobuf(2,bytes,opt)
}

// Pod metdata
#Metadata: {
	annotations?: {[string]: string} @go(Annotations,map[string]string) @protobuf(1,bytes,opt)
	labels?: {[string]: string} @go(Labels,map[string]string) @protobuf(2,bytes,opt)
}

// Parameter indicate a passed string parameter to a service template with an optional default value
#Parameter: {
	// Name is the parameter name
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Default is the default value to use for an input parameter if a value was not supplied
	default?: null | #AnyString @go(Default,*AnyString) @protobuf(2,bytes,opt)

	// Value is the literal value to use for the parameter.
	// If specified in the context of an input parameter, the value takes precedence over any passed values
	value?: null | #AnyString @go(Value,*AnyString) @protobuf(3,bytes,opt)

	// ValueFrom is the source for the output parameter's value
	valueFrom?: null | #ValueFrom @go(ValueFrom,*ValueFrom) @protobuf(4,bytes,opt)

	// GlobalName exports an output parameter to the global scope, making it available as
	// '{{workflow.outputs.parameters.XXXX}} and in workflow.status.outputs.parameters
	globalName?: string @go(GlobalName) @protobuf(5,bytes,opt)

	// Enum holds a list of string values to choose from, for the actual value of the parameter
	enum?: [...#AnyString] @go(Enum,[]AnyString) @protobuf(6,bytes,rep)

	// Description is the parameter description
	description?: null | #AnyString @go(Description,*AnyString) @protobuf(7,bytes,opt)
}

// ValueFrom describes a location in which to obtain the value to a parameter
#ValueFrom: {
	// Path in the container to retrieve an output parameter value from in container templates
	path?: string @go(Path) @protobuf(1,bytes,opt)

	// JSONPath of a resource to retrieve an output parameter value from in resource templates
	jsonPath?: string @go(JSONPath) @protobuf(2,bytes,opt)

	// JQFilter expression against the resource object in resource templates
	jqFilter?: string @go(JQFilter) @protobuf(3,bytes,opt)

	// Selector (https://github.com/antonmedv/expr) that is evaluated against the event to get the value of the parameter. E.g. `payload.message`
	event?: string @go(Event) @protobuf(7,bytes,opt)

	// Parameter reference to a step or dag task in which to retrieve an output parameter value from
	// (e.g. '{{steps.mystep.outputs.myparam}}')
	parameter?: string @go(Parameter) @protobuf(4,bytes,opt)

	// Supplied value to be filled in directly, either through the CLI, API, etc.
	supplied?: null | #SuppliedValueFrom @go(Supplied,*SuppliedValueFrom) @protobuf(6,bytes,opt)

	// ConfigMapKeyRef is configmap selector for input parameter configuration
	configMapKeyRef?: null | apiv1.#ConfigMapKeySelector @go(ConfigMapKeyRef,*apiv1.ConfigMapKeySelector) @protobuf(9,bytes,opt)

	// Default specifies a value to be used if retrieving the value from the specified source fails
	default?: null | #AnyString @go(Default,*AnyString) @protobuf(5,bytes,opt)

	// Expression, if defined, is evaluated to specify the value for the parameter
	expression?: string @go(Expression) @protobuf(8,bytes,rep)
}

// SuppliedValueFrom is a placeholder for a value to be filled in directly, either through the CLI, API, etc.
#SuppliedValueFrom: {
}

// Artifact indicates an artifact to place at a specified path
#Artifact: {
	// name of the artifact. must be unique within a template's inputs/outputs.
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Path is the container path to the artifact
	path?: string @go(Path) @protobuf(2,bytes,opt)

	// mode bits to use on this file, must be a value between 0 and 0777
	// set when loading input artifacts.
	mode?: null | int32 @go(Mode,*int32) @protobuf(3,varint,opt)

	// From allows an artifact to reference an artifact from a previous step
	from?: string @go(From) @protobuf(4,bytes,opt)

	#ArtifactLocation

	// GlobalName exports an output artifact to the global scope, making it available as
	// '{{workflow.outputs.artifacts.XXXX}} and in workflow.status.outputs.artifacts
	globalName?: string @go(GlobalName) @protobuf(6,bytes,opt)

	// Archive controls how the artifact will be saved to the artifact repository.
	archive?: null | #ArchiveStrategy @go(Archive,*ArchiveStrategy) @protobuf(7,bytes,opt)

	// Make Artifacts optional, if Artifacts doesn't generate or exist
	optional?: bool @go(Optional) @protobuf(8,varint,opt)

	// SubPath allows an artifact to be sourced from a subpath within the specified source
	subPath?: string @go(SubPath) @protobuf(9,bytes,opt)

	// If mode is set, apply the permission recursively into the artifact if it is a folder
	recurseMode?: bool @go(RecurseMode) @protobuf(10,varint,opt)

	// FromExpression, if defined, is evaluated to specify the value for the artifact
	fromExpression?: string @go(FromExpression) @protobuf(11,bytes,opt)

	// ArtifactGC describes the strategy to use when to deleting an artifact from completed or deleted workflows
	artifactGC?: null | #ArtifactGC @go(ArtifactGC,*ArtifactGC) @protobuf(12,bytes,opt)

	// Has this been deleted?
	deleted?: bool @go(Deleted) @protobuf(13,varint,opt)
}

// PodGC describes how to delete completed pods as they complete
#PodGC: {
	// Strategy is the strategy to use. One of "OnPodCompletion", "OnPodSuccess", "OnWorkflowCompletion", "OnWorkflowSuccess". If unset, does not delete Pods
	strategy?: #PodGCStrategy @go(Strategy) @protobuf(1,bytes,opt,casttype=PodGCStrategy)

	// LabelSelector is the label selector to check if the pods match the labels before being added to the pod GC queue.
	labelSelector?: null | metav1.#LabelSelector @go(LabelSelector,*metav1.LabelSelector) @protobuf(2,bytes,opt)

	// DeleteDelayDuration specifies the duration before pods in the GC queue get deleted.
	deleteDelayDuration?: null | metav1.#Duration @go(DeleteDelayDuration,*metav1.Duration) @protobuf(3,bytes,opt)
}

// WorkflowLevelArtifactGC describes how to delete artifacts from completed Workflows - this spec is used on the Workflow level
#WorkflowLevelArtifactGC: {
	#ArtifactGC

	// ForceFinalizerRemoval: if set to true, the finalizer will be removed in the case that Artifact GC fails
	forceFinalizerRemoval?: bool @go(ForceFinalizerRemoval) @protobuf(2,bytes,opt)

	// PodSpecPatch holds strategic merge patch to apply against the artgc pod spec.
	podSpecPatch?: string @go(PodSpecPatch) @protobuf(3,bytes,opt)
}

// ArtifactGC describes how to delete artifacts from completed Workflows - this is embedded into the WorkflowLevelArtifactGC, and also used for individual Artifacts to override that as needed
#ArtifactGC: {
	// Strategy is the strategy to use.
	// +kubebuilder:validation:Enum="";OnWorkflowCompletion;OnWorkflowDeletion;Never
	strategy?: #ArtifactGCStrategy @go(Strategy) @protobuf(1,bytes,opt,casttype=ArtifactGCStategy)

	// PodMetadata is an optional field for specifying the Labels and Annotations that should be assigned to the Pod doing the deletion
	podMetadata?: null | #Metadata @go(PodMetadata,*Metadata) @protobuf(2,bytes,opt)

	// ServiceAccountName is an optional field for specifying the Service Account that should be assigned to the Pod doing the deletion
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(3,bytes,opt)
}

// VolumeClaimGC describes how to delete volumes from completed Workflows
#VolumeClaimGC: {
	// Strategy is the strategy to use. One of "OnWorkflowCompletion", "OnWorkflowSuccess". Defaults to "OnWorkflowSuccess"
	strategy?: #VolumeClaimGCStrategy @go(Strategy) @protobuf(1,bytes,opt,casttype=VolumeClaimGCStrategy)
}

// ArchiveStrategy describes how to archive files/directory when saving artifacts
#ArchiveStrategy: {
	tar?:  null | #TarStrategy  @go(Tar,*TarStrategy) @protobuf(1,bytes,opt)
	none?: null | #NoneStrategy @go(None,*NoneStrategy) @protobuf(2,bytes,opt)
	zip?:  null | #ZipStrategy  @go(Zip,*ZipStrategy) @protobuf(3,bytes,opt)
}

// TarStrategy will tar and gzip the file or directory when saving
#TarStrategy: {
	// CompressionLevel specifies the gzip compression level to use for the artifact.
	// Defaults to gzip.DefaultCompression.
	compressionLevel?: null | int32 @go(CompressionLevel,*int32) @protobuf(1,varint,opt)
}

// ZipStrategy will unzip zipped input artifacts
#ZipStrategy: {
}

// NoneStrategy indicates to skip tar process and upload the files or directory tree as independent
// files. Note that if the artifact is a directory, the artifact driver must support the ability to
// save/load the directory appropriately.
#NoneStrategy: {
}

#ArtifactLocationType: _

// ArtifactLocation describes a location for a single or multiple artifacts.
// It is used as single artifact in the context of inputs/outputs (e.g. outputs.artifacts.artname).
// It is also used to describe the location of multiple artifacts such as the archive location
// of a single workflow step, which the executor will use as a default location to store its files.
#ArtifactLocation: {
	// ArchiveLogs indicates if the container logs should be archived
	archiveLogs?: null | bool @go(ArchiveLogs,*bool) @protobuf(1,varint,opt)

	// S3 contains S3 artifact location details
	s3?: null | #S3Artifact @go(S3,*S3Artifact) @protobuf(2,bytes,opt)

	// Git contains git artifact location details
	git?: null | #GitArtifact @go(Git,*GitArtifact) @protobuf(3,bytes,opt)

	// HTTP contains HTTP artifact location details
	http?: null | #HTTPArtifact @go(HTTP,*HTTPArtifact) @protobuf(4,bytes,opt)

	// Artifactory contains artifactory artifact location details
	artifactory?: null | #ArtifactoryArtifact @go(Artifactory,*ArtifactoryArtifact) @protobuf(5,bytes,opt)

	// HDFS contains HDFS artifact location details
	hdfs?: null | #HDFSArtifact @go(HDFS,*HDFSArtifact) @protobuf(6,bytes,opt)

	// Raw contains raw artifact location details
	raw?: null | #RawArtifact @go(Raw,*RawArtifact) @protobuf(7,bytes,opt)

	// OSS contains OSS artifact location details
	oss?: null | #OSSArtifact @go(OSS,*OSSArtifact) @protobuf(8,bytes,opt)

	// GCS contains GCS artifact location details
	gcs?: null | #GCSArtifact @go(GCS,*GCSArtifact) @protobuf(9,bytes,opt)

	// Azure contains Azure Storage artifact location details
	azure?: null | #AzureArtifact @go(Azure,*AzureArtifact) @protobuf(10,bytes,opt)
}

// +protobuf.options.(gogoproto.goproto_stringer)=false
#ArtifactRepositoryRef: {
	// The name of the config map. Defaults to "artifact-repositories".
	configMap?: string @go(ConfigMap) @protobuf(1,bytes,opt)

	// The config map key. Defaults to the value of the "workflows.argoproj.io/default-artifact-repository" annotation.
	key?: string @go(Key) @protobuf(2,bytes,opt)
}

// +protobuf.options.(gogoproto.goproto_stringer)=false
#ArtifactRepositoryRefStatus: {
	#ArtifactRepositoryRef

	// The namespace of the config map. Defaults to the workflow's namespace, or the controller's namespace (if found).
	namespace?: string @go(Namespace) @protobuf(2,bytes,opt)

	// If this ref represents the default artifact repository, rather than a config map.
	default?: bool @go(Default) @protobuf(3,varint,opt)

	// The repository the workflow will use. This maybe empty before v3.1.
	artifactRepository?: null | #ArtifactRepository @go(ArtifactRepository,*ArtifactRepository) @protobuf(4,bytes,opt)
}

#ArtifactSearchQuery: {
	artifactGCStrategies?: {[string]: bool} @go(ArtifactGCStrategies,map[ArtifactGCStrategy]bool) @protobuf(1,bytes,rep,castkey=ArtifactGCStrategy)
	artifactName?: string      @go(ArtifactName) @protobuf(2,bytes,rep)
	templateName?: string      @go(TemplateName) @protobuf(3,bytes,rep)
	nodeId?:       string      @go(NodeId) @protobuf(4,bytes,rep)
	deleted?:      null | bool @go(Deleted,*bool) @protobuf(5,varint,opt)
	nodeTypes?: {[string]: bool} @go(NodeTypes,map[NodeType]bool) @protobuf(6,bytes,opt)
}

// ArtGCStatus maintains state related to ArtifactGC
#ArtGCStatus: {
	// have Pods been started to perform this strategy? (enables us not to re-process what we've already done)
	strategiesProcessed?: {[string]: bool} @go(StrategiesProcessed,map[ArtifactGCStrategy]bool) @protobuf(1,bytes,opt)

	// have completed Pods been processed? (mapped by Pod name)
	// used to prevent re-processing the Status of a Pod more than once
	podsRecouped?: {[string]: bool} @go(PodsRecouped,map[string]bool) @protobuf(2,bytes,opt)

	// if this is true, we already checked to see if we need to do it and we don't
	notSpecified?: bool @go(NotSpecified) @protobuf(3,varint,opt)
}

#ArtifactSearchResult: {
	Artifact: #Artifact @protobuf(1,bytes,opt,name=artifact)
	NodeID:   string    @protobuf(2,bytes,opt,name=nodeID)
}

#ArtifactSearchResults: [...#ArtifactSearchResult]

// Outputs hold parameters, artifacts, and results from a step
#Outputs: {
	// Parameters holds the list of output parameters produced by a step
	// +patchStrategy=merge
	// +patchMergeKey=name
	parameters?: [...#Parameter] @go(Parameters,[]Parameter) @protobuf(1,bytes,rep)

	// Artifacts holds the list of output artifacts produced by a step
	// +patchStrategy=merge
	// +patchMergeKey=name
	artifacts?: #Artifacts @go(Artifacts) @protobuf(2,bytes,rep)

	// Result holds the result (stdout) of a script template
	result?: null | string @go(Result,*string) @protobuf(3,bytes,opt)

	// ExitCode holds the exit code of a script template
	exitCode?: null | string @go(ExitCode,*string) @protobuf(4,bytes,opt)
}

// WorkflowStep is a reference to a template to execute in a series of step
#WorkflowStep: {
	// Name of the step
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Template is the name of the template to execute as the step
	template?: string @go(Template) @protobuf(2,bytes,opt)

	// Inline is the template. Template must be empty if this is declared (and vice-versa).
	inline?: null | #Template @go(Inline,*Template) @protobuf(13,bytes,opt)

	// Arguments hold arguments to the template
	arguments?: #Arguments @go(Arguments) @protobuf(3,bytes,opt)

	// TemplateRef is the reference to the template resource to execute as the step.
	templateRef?: null | #TemplateRef @go(TemplateRef,*TemplateRef) @protobuf(4,bytes,opt)

	// WithItems expands a step into multiple parallel steps from the items in the list
	withItems?: [...#Item] @go(WithItems,[]Item) @protobuf(5,bytes,rep)

	// WithParam expands a step into multiple parallel steps from the value in the parameter,
	// which is expected to be a JSON list.
	withParam?: string @go(WithParam) @protobuf(6,bytes,opt)

	// WithSequence expands a step into a numeric sequence
	withSequence?: null | #Sequence @go(WithSequence,*Sequence) @protobuf(7,bytes,opt)

	// When is an expression in which the step should conditionally execute
	when?: string @go(When) @protobuf(8,bytes,opt)

	// ContinueOn makes argo to proceed with the following step even if this step fails.
	// Errors and Failed states can be specified
	continueOn?: null | #ContinueOn @go(ContinueOn,*ContinueOn) @protobuf(9,bytes,opt)

	// OnExit is a template reference which is invoked at the end of the
	// template, irrespective of the success, failure, or error of the
	// primary template.
	// DEPRECATED: Use Hooks[exit].Template instead.
	onExit?: string @go(OnExit) @protobuf(11,bytes,opt)

	// Hooks holds the lifecycle hook which is invoked at lifecycle of
	// step, irrespective of the success, failure, or error status of the primary step
	hooks?: #LifecycleHooks @go(Hooks) @protobuf(12,bytes,opt)
}

#LifecycleEvent: string

#ExitLifecycleEvent: "exit"

#LifecycleHooks: [string]: #LifecycleHook

#LifecycleHook: {
	// Template is the name of the template to execute by the hook
	template?: string @go(Template) @protobuf(1,bytes,opt)

	// Arguments hold arguments to the template
	arguments?: #Arguments @go(Arguments) @protobuf(2,bytes,opt)

	// TemplateRef is the reference to the template resource to execute by the hook
	templateRef?: null | #TemplateRef @go(TemplateRef,*TemplateRef) @protobuf(3,bytes,opt)

	// Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not
	// be retried and the retry strategy will be ignored
	expression?: string @go(Expression) @protobuf(4,bytes,opt)
}

// Sequence expands a workflow step into numeric range
#Sequence: {
	// Count is number of elements in the sequence (default: 0). Not to be used with end
	count?: null | intstr.#IntOrString @go(Count,*intstr.IntOrString) @protobuf(1,bytes,opt)

	// Number at which to start the sequence (default: 0)
	start?: null | intstr.#IntOrString @go(Start,*intstr.IntOrString) @protobuf(2,bytes,opt)

	// Number at which to end the sequence (default: 0). Not to be used with Count
	end?: null | intstr.#IntOrString @go(End,*intstr.IntOrString) @protobuf(3,bytes,opt)

	// Format is a printf format string to format the value in the sequence
	format?: string @go(Format) @protobuf(4,bytes,opt)
}

// TemplateRef is a reference of template resource.
#TemplateRef: {
	// Name is the resource name of the template.
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Template is the name of referred template in the resource.
	template?: string @go(Template) @protobuf(2,bytes,opt)

	// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
	clusterScope?: bool @go(ClusterScope) @protobuf(4,varint,opt)
}

// Synchronization holds synchronization lock configuration
#Synchronization: {
	// Semaphore holds the Semaphore configuration
	semaphore?: null | #SemaphoreRef @go(Semaphore,*SemaphoreRef) @protobuf(1,bytes,opt)

	// Mutex holds the Mutex lock details
	mutex?: null | #Mutex @go(Mutex,*Mutex) @protobuf(2,bytes,opt)
}

#SynchronizationType: string // #enumSynchronizationType

#enumSynchronizationType:
	#SynchronizationTypeSemaphore |
	#SynchronizationTypeMutex |
	#SynchronizationTypeUnknown

#SynchronizationTypeSemaphore: #SynchronizationType & "Semaphore"
#SynchronizationTypeMutex:     #SynchronizationType & "Mutex"
#SynchronizationTypeUnknown:   #SynchronizationType & "Unknown"

// SemaphoreRef is a reference of Semaphore
#SemaphoreRef: {
	// ConfigMapKeyRef is configmap selector for Semaphore configuration
	configMapKeyRef?: null | apiv1.#ConfigMapKeySelector @go(ConfigMapKeyRef,*apiv1.ConfigMapKeySelector) @protobuf(1,bytes,opt)

	// Namespace is the namespace of the configmap, default: [namespace of workflow]
	namespace?: string @go(Namespace) @protobuf(2,bytes,opt)
}

// Mutex holds Mutex configuration
#Mutex: {
	// name of the mutex
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// Namespace is the namespace of the mutex, default: [namespace of workflow]
	namespace?: string @go(Namespace) @protobuf(2,bytes,opt)
}

// WorkflowTemplateRef is a reference to a WorkflowTemplate resource.
#WorkflowTemplateRef: {
	// Name is the resource name of the workflow template.
	name?: string @go(Name) @protobuf(1,bytes,opt)

	// ClusterScope indicates the referred template is cluster scoped (i.e. a ClusterWorkflowTemplate).
	clusterScope?: bool @go(ClusterScope) @protobuf(2,varint,opt)
}

#ArgumentsProvider: _

// Arguments to a template
#Arguments: {
	// Parameters is the list of parameters to pass to the template or workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	parameters?: [...#Parameter] @go(Parameters,[]Parameter) @protobuf(1,bytes,rep)

	// Artifacts is the list of artifacts to pass to the template or workflow
	// +patchStrategy=merge
	// +patchMergeKey=name
	artifacts?: #Artifacts @go(Artifacts) @protobuf(2,bytes,rep)
}

#Nodes: [string]: #NodeStatus

// UserContainer is a container specified by a user.
#UserContainer: {
	apiv1.#Container

	// MirrorVolumeMounts will mount the same volumes specified in the main container
	// to the container (including artifacts), at the same mountPaths. This enables
	// dind daemon to partially see the same filesystem as the main container in
	// order to use features such as docker volume binding
	mirrorVolumeMounts?: null | bool @go(MirrorVolumeMounts,*bool) @protobuf(2,varint,opt)
}

// WorkflowStatus contains overall status information about a workflow
#WorkflowStatus: {
	// Phase a simple, high-level summary of where the workflow is in its lifecycle.
	// Will be "" (Unknown), "Pending", or "Running" before the workflow is completed, and "Succeeded",
	// "Failed" or "Error" once the workflow has completed.
	phase?: #WorkflowPhase @go(Phase) @protobuf(1,bytes,opt,casttype=WorkflowPhase)

	// Time at which this workflow started
	startedAt?: metav1.#Time @go(StartedAt) @protobuf(2,bytes,opt)

	// Time at which this workflow completed
	finishedAt?: metav1.#Time @go(FinishedAt) @protobuf(3,bytes,opt)

	// EstimatedDuration in seconds.
	estimatedDuration?: #EstimatedDuration @go(EstimatedDuration) @protobuf(16,varint,opt,casttype=EstimatedDuration)

	// Progress to completion
	progress?: #Progress @go(Progress) @protobuf(17,bytes,opt,casttype=Progress)

	// A human readable message indicating details about why the workflow is in this condition.
	message?: string @go(Message) @protobuf(4,bytes,opt)

	// Compressed and base64 decoded Nodes map
	compressedNodes?: string @go(CompressedNodes) @protobuf(5,bytes,opt)

	// Nodes is a mapping between a node ID and the node's status.
	nodes?: #Nodes @go(Nodes) @protobuf(6,bytes,rep)

	// Whether on not node status has been offloaded to a database. If exists, then Nodes and CompressedNodes will be empty.
	// This will actually be populated with a hash of the offloaded data.
	offloadNodeStatusVersion?: string @go(OffloadNodeStatusVersion) @protobuf(10,bytes,rep)

	// StoredTemplates is a mapping between a template ref and the node's status.
	storedTemplates?: {[string]: #Template} @go(StoredTemplates,map[string]Template) @protobuf(9,bytes,rep)

	// PersistentVolumeClaims tracks all PVCs that were created as part of the workflow.
	// The contents of this list are drained at the end of the workflow.
	persistentVolumeClaims?: [...apiv1.#Volume] @go(PersistentVolumeClaims,[]apiv1.Volume) @protobuf(7,bytes,rep)

	// Outputs captures output values and artifact locations produced by the workflow via global outputs
	outputs?: null | #Outputs @go(Outputs,*Outputs) @protobuf(8,bytes,opt)

	// Conditions is a list of conditions the Workflow may have
	conditions?: #Conditions @go(Conditions) @protobuf(13,bytes,rep)

	// ResourcesDuration is the total for the workflow
	resourcesDuration?: #ResourcesDuration @go(ResourcesDuration) @protobuf(12,bytes,opt)

	// StoredWorkflowSpec stores the WorkflowTemplate spec for future execution.
	storedWorkflowTemplateSpec?: null | #WorkflowSpec @go(StoredWorkflowSpec,*WorkflowSpec) @protobuf(14,bytes,opt)

	// Synchronization stores the status of synchronization locks
	synchronization?: null | #SynchronizationStatus @go(Synchronization,*SynchronizationStatus) @protobuf(15,bytes,opt)

	// ArtifactRepositoryRef is used to cache the repository to use so we do not need to determine it everytime we reconcile.
	artifactRepositoryRef?: null | #ArtifactRepositoryRefStatus @go(ArtifactRepositoryRef,*ArtifactRepositoryRefStatus) @protobuf(18,bytes,opt)

	// ArtifactGCStatus maintains the status of Artifact Garbage Collection
	artifactGCStatus?: null | #ArtGCStatus @go(ArtifactGCStatus,*ArtGCStatus) @protobuf(19,bytes,opt)
}

#RetryPolicy: string // #enumRetryPolicy

#enumRetryPolicy:
	#RetryPolicyAlways |
	#RetryPolicyOnFailure |
	#RetryPolicyOnError |
	#RetryPolicyOnTransientError

#RetryPolicyAlways:           #RetryPolicy & "Always"
#RetryPolicyOnFailure:        #RetryPolicy & "OnFailure"
#RetryPolicyOnError:          #RetryPolicy & "OnError"
#RetryPolicyOnTransientError: #RetryPolicy & "OnTransientError"

// Backoff is a backoff strategy to use within retryStrategy
#Backoff: {
	// Duration is the amount to back off. Default unit is seconds, but could also be a duration (e.g. "2m", "1h")
	duration?: string @go(Duration) @protobuf(1,varint,opt)

	// Factor is a factor to multiply the base duration after each failed retry
	factor?: null | intstr.#IntOrString @go(Factor,*intstr.IntOrString) @protobuf(2,varint,opt)

	// MaxDuration is the maximum amount of time allowed for a workflow in the backoff strategy
	maxDuration?: string @go(MaxDuration) @protobuf(3,varint,opt)
}

// RetryNodeAntiAffinity is a placeholder for future expansion, only empty nodeAntiAffinity is allowed.
// In order to prevent running steps on the same host, it uses "kubernetes.io/hostname".
#RetryNodeAntiAffinity: {
}

// RetryAffinity prevents running steps on the same host.
#RetryAffinity: {
	nodeAntiAffinity?: null | #RetryNodeAntiAffinity @go(NodeAntiAffinity,*RetryNodeAntiAffinity) @protobuf(1,bytes,opt)
}

// RetryStrategy provides controls on how to retry a workflow step
#RetryStrategy: {
	// Limit is the maximum number of retry attempts when retrying a container. It does not include the original
	// container; the maximum number of total attempts will be `limit + 1`.
	limit?: null | intstr.#IntOrString @go(Limit,*intstr.IntOrString) @protobuf(1,varint,opt)

	// RetryPolicy is a policy of NodePhase statuses that will be retried
	retryPolicy?: #RetryPolicy @go(RetryPolicy) @protobuf(2,bytes,opt,casttype=RetryPolicy)

	// Backoff is a backoff strategy
	backoff?: null | #Backoff @go(Backoff,*Backoff) @protobuf(3,bytes,opt,casttype=Backoff)

	// Affinity prevents running workflow's step on the same host
	affinity?: null | #RetryAffinity @go(Affinity,*RetryAffinity) @protobuf(4,bytes,opt)

	// Expression is a condition expression for when a node will be retried. If it evaluates to false, the node will not
	// be retried and the retry strategy will be ignored
	expression?: string @go(Expression) @protobuf(5,bytes,opt)
}

// The amount of requested resource * the duration that request was used.
// This is represented as duration in seconds, so can be converted to and from
// duration (with loss of precision).
#ResourceDuration: int64

// This contains each duration by request requested.
// e.g. 100m CPU * 1h, 1Gi memory * 1h
#ResourcesDuration: {[string]: #ResourceDuration}

#Conditions: [...#Condition]

#ConditionType: string // #enumConditionType

#enumConditionType:
	#ConditionTypeSubmissionError |
	#ConditionTypeCompleted |
	#ConditionTypePodRunning |
	#ConditionTypeSpecWarning |
	#ConditionTypeSpecError |
	#ConditionTypeMetricsError |
	#ConditionTypeArtifactGCError

// ConditionTypeCompleted is a signifies the workflow has completed
#ConditionTypeCompleted: #ConditionType & "Completed"

// ConditionTypePodRunning any workflow pods are currently running
#ConditionTypePodRunning: #ConditionType & "PodRunning"

// ConditionTypeSpecWarning is a warning on the current application spec
#ConditionTypeSpecWarning: #ConditionType & "SpecWarning"

// ConditionTypeSpecWarning is an error on the current application spec
#ConditionTypeSpecError: #ConditionType & "SpecError"

// ConditionTypeMetricsError is an error during metric emission
#ConditionTypeMetricsError: #ConditionType & "MetricsError"

//ConditionTypeArtifactGCError is an error on artifact garbage collection
#ConditionTypeArtifactGCError: #ConditionType & "ArtifactGCError"

#Condition: {
	// Type is the type of condition
	type?: #ConditionType @go(Type) @protobuf(1,bytes,opt,casttype=ConditionType)

	// Status is the status of the condition
	status?: metav1.#ConditionStatus @go(Status) @protobuf(2,bytes,opt,casttype=k8s.io/apimachinery/pkg/apis/meta/v1.ConditionStatus)

	// Message is the condition message
	message?: string @go(Message) @protobuf(3,bytes,opt)
}

// NodeStatus contains status information about an individual node in the workflow
#NodeStatus: {
	// ID is a unique identifier of a node within the worklow
	// It is implemented as a hash of the node name, which makes the ID deterministic
	id: string @go(ID) @protobuf(1,bytes,opt)

	// Name is unique name in the node tree used to generate the node ID
	name: string @go(Name) @protobuf(2,bytes,opt)

	// DisplayName is a human readable representation of the node. Unique within a template boundary
	displayName?: string @go(DisplayName) @protobuf(3,bytes,opt)

	// Type indicates type of node
	type: #NodeType @go(Type) @protobuf(4,bytes,opt,casttype=NodeType)

	// TemplateName is the template name which this node corresponds to.
	// Not applicable to virtual nodes (e.g. Retry, StepGroup)
	templateName?: string @go(TemplateName) @protobuf(5,bytes,opt)

	// TemplateRef is the reference to the template resource which this node corresponds to.
	// Not applicable to virtual nodes (e.g. Retry, StepGroup)
	templateRef?: null | #TemplateRef @go(TemplateRef,*TemplateRef) @protobuf(6,bytes,opt)

	// TemplateScope is the template scope in which the template of this node was retrieved.
	templateScope?: string @go(TemplateScope) @protobuf(20,bytes,opt)

	// Phase a simple, high-level summary of where the node is in its lifecycle.
	// Can be used as a state machine.
	// Will be one of these values "Pending", "Running" before the node is completed, or "Succeeded",
	// "Skipped", "Failed", "Error", or "Omitted" as a final state.
	phase?: #NodePhase @go(Phase) @protobuf(7,bytes,opt,casttype=NodePhase)

	// BoundaryID indicates the node ID of the associated template root node in which this node belongs to
	boundaryID?: string @go(BoundaryID) @protobuf(8,bytes,opt)

	// A human readable message indicating details about why the node is in this condition.
	message?: string @go(Message) @protobuf(9,bytes,opt)

	// Time at which this node started
	startedAt?: metav1.#Time @go(StartedAt) @protobuf(10,bytes,opt)

	// Time at which this node completed
	finishedAt?: metav1.#Time @go(FinishedAt) @protobuf(11,bytes,opt)

	// EstimatedDuration in seconds.
	estimatedDuration?: #EstimatedDuration @go(EstimatedDuration) @protobuf(24,varint,opt,casttype=EstimatedDuration)

	// Progress to completion
	progress?: #Progress @go(Progress) @protobuf(26,bytes,opt,casttype=Progress)

	// ResourcesDuration is indicative, but not accurate, resource duration. This is populated when the nodes completes.
	resourcesDuration?: #ResourcesDuration @go(ResourcesDuration) @protobuf(21,bytes,opt)

	// PodIP captures the IP of the pod for daemoned steps
	podIP?: string @go(PodIP) @protobuf(12,bytes,opt)

	// Daemoned tracks whether or not this node was daemoned and need to be terminated
	daemoned?: null | bool @go(Daemoned,*bool) @protobuf(13,varint,opt)

	// Inputs captures input parameter values and artifact locations supplied to this template invocation
	inputs?: null | #Inputs @go(Inputs,*Inputs) @protobuf(14,bytes,opt)

	// Outputs captures output parameter values and artifact locations produced by this template invocation
	outputs?: null | #Outputs @go(Outputs,*Outputs) @protobuf(15,bytes,opt)

	// Children is a list of child node IDs
	children?: [...string] @go(Children,[]string) @protobuf(16,bytes,rep)

	// OutboundNodes tracks the node IDs which are considered "outbound" nodes to a template invocation.
	// For every invocation of a template, there are nodes which we considered as "outbound". Essentially,
	// these are last nodes in the execution sequence to run, before the template is considered completed.
	// These nodes are then connected as parents to a following step.
	//
	// In the case of single pod steps (i.e. container, script, resource templates), this list will be nil
	// since the pod itself is already considered the "outbound" node.
	// In the case of DAGs, outbound nodes are the "target" tasks (tasks with no children).
	// In the case of steps, outbound nodes are all the containers involved in the last step group.
	// NOTE: since templates are composable, the list of outbound nodes are carried upwards when
	// a DAG/steps template invokes another DAG/steps template. In other words, the outbound nodes of
	// a template, will be a superset of the outbound nodes of its last children.
	outboundNodes?: [...string] @go(OutboundNodes,[]string) @protobuf(17,bytes,rep)

	// HostNodeName name of the Kubernetes node on which the Pod is running, if applicable
	hostNodeName?: string @go(HostNodeName) @protobuf(22,bytes,rep)

	// MemoizationStatus holds information about cached nodes
	memoizationStatus?: null | #MemoizationStatus @go(MemoizationStatus,*MemoizationStatus) @protobuf(23,varint,opt)

	// SynchronizationStatus is the synchronization status of the node
	synchronizationStatus?: null | #NodeSynchronizationStatus @go(SynchronizationStatus,*NodeSynchronizationStatus) @protobuf(25,bytes,opt)
}

// S3Bucket contains the access information required for interfacing with an S3 bucket
#S3Bucket: {
	// Endpoint is the hostname of the bucket endpoint
	endpoint?: string @go(Endpoint) @protobuf(1,bytes,opt)

	// Bucket is the name of the bucket
	bucket?: string @go(Bucket) @protobuf(2,bytes,opt)

	// Region contains the optional bucket region
	region?: string @go(Region) @protobuf(3,bytes,opt)

	// Insecure will connect to the service with TLS
	insecure?: null | bool @go(Insecure,*bool) @protobuf(4,varint,opt)

	// AccessKeySecret is the secret selector to the bucket's access key
	accessKeySecret?: null | apiv1.#SecretKeySelector @go(AccessKeySecret,*apiv1.SecretKeySelector) @protobuf(5,bytes,opt)

	// SecretKeySecret is the secret selector to the bucket's secret key
	secretKeySecret?: null | apiv1.#SecretKeySelector @go(SecretKeySecret,*apiv1.SecretKeySelector) @protobuf(6,bytes,opt)

	// RoleARN is the Amazon Resource Name (ARN) of the role to assume.
	roleARN?: string @go(RoleARN) @protobuf(7,bytes,opt)

	// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
	useSDKCreds?: bool @go(UseSDKCreds) @protobuf(8,varint,opt)

	// CreateBucketIfNotPresent tells the driver to attempt to create the S3 bucket for output artifacts, if it doesn't exist. Setting Enabled Encryption will apply either SSE-S3 to the bucket if KmsKeyId is not set or SSE-KMS if it is.
	createBucketIfNotPresent?: null | #CreateS3BucketOptions @go(CreateBucketIfNotPresent,*CreateS3BucketOptions) @protobuf(9,bytes,opt)
	encryptionOptions?:        null | #S3EncryptionOptions   @go(EncryptionOptions,*S3EncryptionOptions) @protobuf(10,bytes,opt)

	// CASecret specifies the secret that contains the CA, used to verify the TLS connection
	caSecret?: null | apiv1.#SecretKeySelector @go(CASecret,*apiv1.SecretKeySelector) @protobuf(11,bytes,opt)
}

// S3EncryptionOptions used to determine encryption options during s3 operations
#S3EncryptionOptions: {
	// KMSKeyId tells the driver to encrypt the object using the specified KMS Key.
	kmsKeyId?: string @go(KmsKeyId) @protobuf(1,bytes,opt)

	// KmsEncryptionContext is a json blob that contains an encryption context. See https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#encrypt_context for more information
	kmsEncryptionContext?: string @go(KmsEncryptionContext) @protobuf(2,bytes,opt)

	// EnableEncryption tells the driver to encrypt objects if set to true. If kmsKeyId and serverSideCustomerKeySecret are not set, SSE-S3 will be used
	enableEncryption?: bool @go(EnableEncryption) @protobuf(3,varint,opt)

	// ServerSideCustomerKeySecret tells the driver to encrypt the output artifacts using SSE-C with the specified secret.
	serverSideCustomerKeySecret?: null | apiv1.#SecretKeySelector @go(ServerSideCustomerKeySecret,*apiv1.SecretKeySelector) @protobuf(4,bytes,opt)
}

// CreateS3BucketOptions options used to determine automatic automatic bucket-creation process
#CreateS3BucketOptions: {
	// ObjectLocking Enable object locking
	objectLocking?: bool @go(ObjectLocking) @protobuf(3,varint,opt)
}

// S3Artifact is the location of an S3 artifact
#S3Artifact: {
	#S3Bucket

	// Key is the key in the bucket where the artifact resides
	key?: string @go(Key) @protobuf(2,bytes,opt)
}

// GitArtifact is the location of an git artifact
#GitArtifact: {
	// Repo is the git repository
	repo: string @go(Repo) @protobuf(1,bytes,opt)

	// Revision is the git commit, tag, branch to checkout
	revision?: string @go(Revision) @protobuf(2,bytes,opt)

	// Depth specifies clones/fetches should be shallow and include the given
	// number of commits from the branch tip
	depth?: null | uint64 @go(Depth,*uint64) @protobuf(3,bytes,opt)

	// Fetch specifies a number of refs that should be fetched before checkout
	fetch?: [...string] @go(Fetch,[]string) @protobuf(4,bytes,rep)

	// UsernameSecret is the secret selector to the repository username
	usernameSecret?: null | apiv1.#SecretKeySelector @go(UsernameSecret,*apiv1.SecretKeySelector) @protobuf(5,bytes,opt)

	// PasswordSecret is the secret selector to the repository password
	passwordSecret?: null | apiv1.#SecretKeySelector @go(PasswordSecret,*apiv1.SecretKeySelector) @protobuf(6,bytes,opt)

	// SSHPrivateKeySecret is the secret selector to the repository ssh private key
	sshPrivateKeySecret?: null | apiv1.#SecretKeySelector @go(SSHPrivateKeySecret,*apiv1.SecretKeySelector) @protobuf(7,bytes,opt)

	// InsecureIgnoreHostKey disables SSH strict host key checking during git clone
	insecureIgnoreHostKey?: bool @go(InsecureIgnoreHostKey) @protobuf(8,varint,opt)

	// DisableSubmodules disables submodules during git clone
	disableSubmodules?: bool @go(DisableSubmodules) @protobuf(9,varint,opt)

	// SingleBranch enables single branch clone, using the `branch` parameter
	singleBranch?: bool @go(SingleBranch) @protobuf(10,varint,opt)

	// Branch is the branch to fetch when `SingleBranch` is enabled
	branch?: string @go(Branch) @protobuf(11,bytes,opt)
}

// ArtifactoryAuth describes the secret selectors required for authenticating to artifactory
#ArtifactoryAuth: {
	// UsernameSecret is the secret selector to the repository username
	usernameSecret?: null | apiv1.#SecretKeySelector @go(UsernameSecret,*apiv1.SecretKeySelector) @protobuf(1,bytes,opt)

	// PasswordSecret is the secret selector to the repository password
	passwordSecret?: null | apiv1.#SecretKeySelector @go(PasswordSecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)
}

// ArtifactoryArtifact is the location of an artifactory artifact
#ArtifactoryArtifact: {
	// URL of the artifact
	url: string @go(URL) @protobuf(1,bytes,opt)

	#ArtifactoryAuth
}

// AzureBlobContainer contains the access information for interfacing with an Azure Blob Storage container
#AzureBlobContainer: {
	// Endpoint is the service url associated with an account. It is most likely "https://<ACCOUNT_NAME>.blob.core.windows.net"
	endpoint: string @go(Endpoint) @protobuf(1,bytes,opt)

	// Container is the container where resources will be stored
	container: string @go(Container) @protobuf(2,bytes,opt)

	// AccountKeySecret is the secret selector to the Azure Blob Storage account access key
	accountKeySecret?: null | apiv1.#SecretKeySelector @go(AccountKeySecret,*apiv1.SecretKeySelector) @protobuf(3,bytes,opt)

	// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
	useSDKCreds?: bool @go(UseSDKCreds) @protobuf(4,varint,opt)
}

// AzureArtifact is the location of a an Azure Storage artifact
#AzureArtifact: {
	#AzureBlobContainer

	// Blob is the blob name (i.e., path) in the container where the artifact resides
	blob: string @go(Blob) @protobuf(2,bytes,opt)
}

// HDFSArtifact is the location of an HDFS artifact
#HDFSArtifact: {
	#HDFSConfig

	// Path is a file path in HDFS
	path: string @go(Path) @protobuf(2,bytes,opt)

	// Force copies a file forcibly even if it exists
	force?: bool @go(Force) @protobuf(3,varint,opt)
}

// HDFSConfig is configurations for HDFS
#HDFSConfig: {
	#HDFSKrbConfig

	// Addresses is accessible addresses of HDFS name nodes
	addresses?: [...string] @go(Addresses,[]string) @protobuf(2,bytes,rep)

	// HDFSUser is the user to access HDFS file system.
	// It is ignored if either ccache or keytab is used.
	hdfsUser?: string @go(HDFSUser) @protobuf(3,bytes,opt)
}

// HDFSKrbConfig is auth configurations for Kerberos
#HDFSKrbConfig: {
	// KrbCCacheSecret is the secret selector for Kerberos ccache
	// Either ccache or keytab can be set to use Kerberos.
	krbCCacheSecret?: null | apiv1.#SecretKeySelector @go(KrbCCacheSecret,*apiv1.SecretKeySelector) @protobuf(1,bytes,opt)

	// KrbKeytabSecret is the secret selector for Kerberos keytab
	// Either ccache or keytab can be set to use Kerberos.
	krbKeytabSecret?: null | apiv1.#SecretKeySelector @go(KrbKeytabSecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)

	// KrbUsername is the Kerberos username used with Kerberos keytab
	// It must be set if keytab is used.
	krbUsername?: string @go(KrbUsername) @protobuf(3,bytes,opt)

	// KrbRealm is the Kerberos realm used with Kerberos keytab
	// It must be set if keytab is used.
	krbRealm?: string @go(KrbRealm) @protobuf(4,bytes,opt)

	// KrbConfig is the configmap selector for Kerberos config as string
	// It must be set if either ccache or keytab is used.
	krbConfigConfigMap?: null | apiv1.#ConfigMapKeySelector @go(KrbConfigConfigMap,*apiv1.ConfigMapKeySelector) @protobuf(5,bytes,opt)

	// KrbServicePrincipalName is the principal name of Kerberos service
	// It must be set if either ccache or keytab is used.
	krbServicePrincipalName?: string @go(KrbServicePrincipalName) @protobuf(6,bytes,opt)
}

// RawArtifact allows raw string content to be placed as an artifact in a container
#RawArtifact: {
	// Data is the string contents of the artifact
	data: string @go(Data) @protobuf(1,bytes,opt)
}

// Header indicate a key-value request header to be used when fetching artifacts over HTTP
#Header: {
	// Name is the header name
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Value is the literal value to use for the header
	value: string @go(Value) @protobuf(2,bytes,opt)
}

// BasicAuth describes the secret selectors required for basic authentication
#BasicAuth: {
	// UsernameSecret is the secret selector to the repository username
	usernameSecret?: null | apiv1.#SecretKeySelector @go(UsernameSecret,*apiv1.SecretKeySelector) @protobuf(1,bytes,opt)

	// PasswordSecret is the secret selector to the repository password
	passwordSecret?: null | apiv1.#SecretKeySelector @go(PasswordSecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)
}

// ClientCertAuth holds necessary information for client authentication via certificates
#ClientCertAuth: {
	clientCertSecret?: null | apiv1.#SecretKeySelector @go(ClientCertSecret,*apiv1.SecretKeySelector) @protobuf(1,bytes,opt)
	clientKeySecret?:  null | apiv1.#SecretKeySelector @go(ClientKeySecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)
}

// OAuth2Auth holds all information for client authentication via OAuth2 tokens
#OAuth2Auth: {
	clientIDSecret?:     null | apiv1.#SecretKeySelector @go(ClientIDSecret,*apiv1.SecretKeySelector) @protobuf(1,bytes,opt)
	clientSecretSecret?: null | apiv1.#SecretKeySelector @go(ClientSecretSecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)
	tokenURLSecret?:     null | apiv1.#SecretKeySelector @go(TokenURLSecret,*apiv1.SecretKeySelector) @protobuf(3,bytes,opt)
	scopes?: [...string] @go(Scopes,[]string) @protobuf(5,bytes,rep)
	endpointParams?: [...#OAuth2EndpointParam] @go(EndpointParams,[]OAuth2EndpointParam) @protobuf(6,bytes,rep)
}

// EndpointParam is for requesting optional fields that should be sent in the oauth request
#OAuth2EndpointParam: {
	// Name is the header name
	key: string @go(Key) @protobuf(1,bytes,opt)

	// Value is the literal value to use for the header
	value?: string @go(Value) @protobuf(2,bytes,opt)
}

#HTTPAuth: {
	clientCert?: #ClientCertAuth @go(ClientCert) @protobuf(1,bytes,opt)
	oauth2?:     #OAuth2Auth     @go(OAuth2) @protobuf(2,bytes,opt)
	basicAuth?:  #BasicAuth      @go(BasicAuth) @protobuf(3,bytes,opt)
}

// HTTPArtifact allows a file served on HTTP to be placed as an input artifact in a container
#HTTPArtifact: {
	// URL of the artifact
	url: string @go(URL) @protobuf(1,bytes,opt)

	// Headers are an optional list of headers to send with HTTP requests for artifacts
	headers?: [...#Header] @go(Headers,[]Header) @protobuf(2,bytes,rep)

	// Auth contains information for client authentication
	auth?: null | #HTTPAuth @go(Auth,*HTTPAuth) @protobuf(3,bytes,opt)
}

// GCSBucket contains the access information for interfacring with a GCS bucket
#GCSBucket: {
	// Bucket is the name of the bucket
	bucket?: string @go(Bucket) @protobuf(1,bytes,opt)

	// ServiceAccountKeySecret is the secret selector to the bucket's service account key
	serviceAccountKeySecret?: null | apiv1.#SecretKeySelector @go(ServiceAccountKeySecret,*apiv1.SecretKeySelector) @protobuf(2,bytes,opt)
}

// GCSArtifact is the location of a GCS artifact
#GCSArtifact: {
	#GCSBucket

	// Key is the path in the bucket where the artifact resides
	key: string @go(Key) @protobuf(2,bytes,opt)
}

// OSSBucket contains the access information required for interfacing with an Alibaba Cloud OSS bucket
#OSSBucket: {
	// Endpoint is the hostname of the bucket endpoint
	endpoint?: string @go(Endpoint) @protobuf(1,bytes,opt)

	// Bucket is the name of the bucket
	bucket?: string @go(Bucket) @protobuf(2,bytes,opt)

	// AccessKeySecret is the secret selector to the bucket's access key
	accessKeySecret?: null | apiv1.#SecretKeySelector @go(AccessKeySecret,*apiv1.SecretKeySelector) @protobuf(3,bytes,opt)

	// SecretKeySecret is the secret selector to the bucket's secret key
	secretKeySecret?: null | apiv1.#SecretKeySelector @go(SecretKeySecret,*apiv1.SecretKeySelector) @protobuf(4,bytes,opt)

	// CreateBucketIfNotPresent tells the driver to attempt to create the OSS bucket for output artifacts, if it doesn't exist
	createBucketIfNotPresent?: bool @go(CreateBucketIfNotPresent) @protobuf(5,varint,opt)

	// SecurityToken is the user's temporary security token. For more details, check out: https://www.alibabacloud.com/help/doc-detail/100624.htm
	securityToken?: string @go(SecurityToken) @protobuf(6,bytes,opt)

	// LifecycleRule specifies how to manage bucket's lifecycle
	lifecycleRule?: null | #OSSLifecycleRule @go(LifecycleRule,*OSSLifecycleRule) @protobuf(7,bytes,opt)

	// UseSDKCreds tells the driver to figure out credentials based on sdk defaults.
	useSDKCreds?: bool @go(UseSDKCreds) @protobuf(8,varint,opt)
}

// OSSArtifact is the location of an Alibaba Cloud OSS artifact
#OSSArtifact: {
	#OSSBucket

	// Key is the path in the bucket where the artifact resides
	key: string @go(Key) @protobuf(2,bytes,opt)
}

// OSSLifecycleRule specifies how to manage bucket's lifecycle
#OSSLifecycleRule: {
	// MarkInfrequentAccessAfterDays is the number of days before we convert the objects in the bucket to Infrequent Access (IA) storage type
	markInfrequentAccessAfterDays?: int32 @go(MarkInfrequentAccessAfterDays) @protobuf(1,varint,opt)

	// MarkDeletionAfterDays is the number of days before we delete objects in the bucket
	markDeletionAfterDays?: int32 @go(MarkDeletionAfterDays) @protobuf(2,varint,opt)
}

// ExecutorConfig holds configurations of an executor container.
#ExecutorConfig: {
	// ServiceAccountName specifies the service account name of the executor container.
	serviceAccountName?: string @go(ServiceAccountName) @protobuf(1,bytes,opt)
}

// ScriptTemplate is a template subtype to enable scripting through code steps
#ScriptTemplate: {
	apiv1.#Container

	// Source contains the source code of the script to execute
	source: string @go(Source) @protobuf(2,bytes,opt)
}

// ResourceTemplate is a template subtype to manipulate kubernetes resources
#ResourceTemplate: {
	// Action is the action to perform to the resource.
	// Must be one of: get, create, apply, delete, replace, patch
	action: string @go(Action) @protobuf(1,bytes,opt)

	// MergeStrategy is the strategy used to merge a patch. It defaults to "strategic"
	// Must be one of: strategic, merge, json
	mergeStrategy?: string @go(MergeStrategy) @protobuf(2,bytes,opt)

	// Manifest contains the kubernetes manifest
	manifest?: string @go(Manifest) @protobuf(3,bytes,opt)

	// ManifestFrom is the source for a single kubernetes manifest
	manifestFrom?: null | #ManifestFrom @go(ManifestFrom,*ManifestFrom) @protobuf(8,bytes,opt)

	// SetOwnerReference sets the reference to the workflow on the OwnerReference of generated resource.
	setOwnerReference?: bool @go(SetOwnerReference) @protobuf(4,varint,opt)

	// SuccessCondition is a label selector expression which describes the conditions
	// of the k8s resource in which it is acceptable to proceed to the following step
	successCondition?: string @go(SuccessCondition) @protobuf(5,bytes,opt)

	// FailureCondition is a label selector expression which describes the conditions
	// of the k8s resource in which the step was considered failed
	failureCondition?: string @go(FailureCondition) @protobuf(6,bytes,opt)

	// Flags is a set of additional options passed to kubectl before submitting a resource
	// I.e. to disable resource validation:
	// flags: [
	// 	"--validate=false"  # disable resource validation
	// ]
	flags?: [...string] @go(Flags,[]string) @protobuf(7,varint,opt)
}

#ManifestFrom: {
	// Artifact contains the artifact to use
	artifact?: null | #Artifact @go(Artifact,*Artifact) @protobuf(1,bytes,opt)
}

// DAGTemplate is a template subtype for directed acyclic graph templates
#DAGTemplate: {
	// Target are one or more names of targets to execute in a DAG
	target?: string @go(Target) @protobuf(1,bytes,opt)

	// Tasks are a list of DAG tasks
	// +patchStrategy=merge
	// +patchMergeKey=name
	tasks: [...#DAGTask] @go(Tasks,[]DAGTask) @protobuf(2,bytes,rep)

	// This flag is for DAG logic. The DAG logic has a built-in "fail fast" feature to stop scheduling new steps,
	// as soon as it detects that one of the DAG nodes is failed. Then it waits until all DAG nodes are completed
	// before failing the DAG itself.
	// The FailFast flag default is true,  if set to false, it will allow a DAG to run all branches of the DAG to
	// completion (either success or failure), regardless of the failed outcomes of branches in the DAG.
	// More info and example about this feature at https://github.com/argoproj/argo-workflows/issues/1442
	failFast?: null | bool @go(FailFast,*bool) @protobuf(3,varint,opt)
}

// DAGTask represents a node in the graph during DAG execution
#DAGTask: {
	// Name is the name of the target
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Name of template to execute
	template?: string @go(Template) @protobuf(2,bytes,opt)

	// Inline is the template. Template must be empty if this is declared (and vice-versa).
	inline?: null | #Template @go(Inline,*Template) @protobuf(14,bytes,opt)

	// Arguments are the parameter and artifact arguments to the template
	arguments?: #Arguments @go(Arguments) @protobuf(3,bytes,opt)

	// TemplateRef is the reference to the template resource to execute.
	templateRef?: null | #TemplateRef @go(TemplateRef,*TemplateRef) @protobuf(4,bytes,opt)

	// Dependencies are name of other targets which this depends on
	dependencies?: [...string] @go(Dependencies,[]string) @protobuf(5,bytes,rep)

	// WithItems expands a task into multiple parallel tasks from the items in the list
	withItems?: [...#Item] @go(WithItems,[]Item) @protobuf(6,bytes,rep)

	// WithParam expands a task into multiple parallel tasks from the value in the parameter,
	// which is expected to be a JSON list.
	withParam?: string @go(WithParam) @protobuf(7,bytes,opt)

	// WithSequence expands a task into a numeric sequence
	withSequence?: null | #Sequence @go(WithSequence,*Sequence) @protobuf(8,bytes,opt)

	// When is an expression in which the task should conditionally execute
	when?: string @go(When) @protobuf(9,bytes,opt)

	// ContinueOn makes argo to proceed with the following step even if this step fails.
	// Errors and Failed states can be specified
	continueOn?: null | #ContinueOn @go(ContinueOn,*ContinueOn) @protobuf(10,bytes,opt)

	// OnExit is a template reference which is invoked at the end of the
	// template, irrespective of the success, failure, or error of the
	// primary template.
	// DEPRECATED: Use Hooks[exit].Template instead.
	onExit?: string @go(OnExit) @protobuf(11,bytes,opt)

	// Depends are name of other targets which this depends on
	depends?: string @go(Depends) @protobuf(12,bytes,opt)

	// Hooks hold the lifecycle hook which is invoked at lifecycle of
	// task, irrespective of the success, failure, or error status of the primary task
	hooks?: #LifecycleHooks @go(Hooks) @protobuf(13,bytes,opt)
}

// SuspendTemplate is a template subtype to suspend a workflow at a predetermined point in time
#SuspendTemplate: {
	// Duration is the seconds to wait before automatically resuming a template. Must be a string. Default unit is seconds.
	// Could also be a Duration, e.g.: "2m", "6h"
	duration?: string @go(Duration) @protobuf(1,bytes,opt)
}

#LogsSuffix: "-logs"

// ContinueOn defines if a workflow should continue even if a task or step fails/errors.
// It can be specified if the workflow should continue when the pod errors, fails or both.
#ContinueOn: {
	// +optional
	error?: bool @go(Error) @protobuf(1,varint,opt)

	// +optional
	failed?: bool @go(Failed) @protobuf(2,varint,opt)
}

#MetricType: string // #enumMetricType

#enumMetricType:
	#MetricTypeGauge |
	#MetricTypeHistogram |
	#MetricTypeCounter |
	#MetricTypeUnknown

#MetricTypeGauge:     #MetricType & "Gauge"
#MetricTypeHistogram: #MetricType & "Histogram"
#MetricTypeCounter:   #MetricType & "Counter"
#MetricTypeUnknown:   #MetricType & "Unknown"

// Metrics are a list of metrics emitted from a Workflow/Template
#Metrics: {
	// Prometheus is a list of prometheus metrics to be emitted
	prometheus: [...null | #Prometheus] @go(Prometheus,[]*Prometheus) @protobuf(1,bytes,rep)
}

// Prometheus is a prometheus metric to be emitted
#Prometheus: {
	// Name is the name of the metric
	name: string @go(Name) @protobuf(1,bytes,opt)

	// Labels is a list of metric labels
	labels?: [...null | #MetricLabel] @go(Labels,[]*MetricLabel) @protobuf(2,bytes,rep)

	// Help is a string that describes the metric
	help: string @go(Help) @protobuf(3,bytes,opt)

	// When is a conditional statement that decides when to emit the metric
	when?: string @go(When) @protobuf(4,bytes,opt)

	// Gauge is a gauge metric
	gauge?: null | #Gauge @go(Gauge,*Gauge) @protobuf(5,bytes,opt)

	// Histogram is a histogram metric
	histogram?: null | #Histogram @go(Histogram,*Histogram) @protobuf(6,bytes,opt)

	// Counter is a counter metric
	counter?: null | #Counter @go(Counter,*Counter) @protobuf(7,bytes,opt)
}

// MetricLabel is a single label for a prometheus metric
#MetricLabel: {
	key:   string @go(Key) @protobuf(1,bytes,opt)
	value: string @go(Value) @protobuf(2,bytes,opt)
}

// Gauge is a Gauge prometheus metric
#Gauge: {
	// Value is the value to be used in the operation with the metric's current value. If no operation is set,
	// value is the value of the metric
	value: string @go(Value) @protobuf(1,bytes,opt)

	// Realtime emits this metric in real time if applicable
	realtime?: null | bool @go(Realtime,*bool) @protobuf(2,varint,opt)

	// Operation defines the operation to apply with value and the metrics' current value
	// +optional
	operation?: #GaugeOperation @go(Operation) @protobuf(3,bytes,opt)
}

// A GaugeOperation is the set of operations that can be used in a gauge metric.
#GaugeOperation: string // #enumGaugeOperation

#enumGaugeOperation:
	#GaugeOperationSet |
	#GaugeOperationAdd |
	#GaugeOperationSub

#GaugeOperationSet: #GaugeOperation & "Set"
#GaugeOperationAdd: #GaugeOperation & "Add"
#GaugeOperationSub: #GaugeOperation & "Sub"

// Histogram is a Histogram prometheus metric
#Histogram: {
	// Value is the value of the metric
	value: string @go(Value) @protobuf(3,bytes,opt)

	// Buckets is a list of bucket divisors for the histogram
	buckets: [...#Amount] @go(Buckets,[]Amount) @protobuf(4,bytes,rep)
}

// Counter is a Counter prometheus metric
#Counter: {
	// Value is the value of the metric
	value: string @go(Value) @protobuf(1,bytes,opt)
}

// Memoization enables caching for the Outputs of the template
#Memoize: {
	// Key is the key to use as the caching key
	key: string @go(Key) @protobuf(1,bytes,opt)

	// Cache sets and configures the kind of cache
	cache?: null | #Cache @go(Cache,*Cache) @protobuf(2,bytes,opt)

	// MaxAge is the maximum age (e.g. "180s", "24h") of an entry that is still considered valid. If an entry is older
	// than the MaxAge, it will be ignored.
	maxAge: string @go(MaxAge) @protobuf(3,bytes,opt)
}

// MemoizationStatus is the status of this memoized node
#MemoizationStatus: {
	// Hit indicates whether this node was created from a cache entry
	hit: bool @go(Hit) @protobuf(1,bytes,opt)

	// Key is the name of the key used for this node's cache
	key: string @go(Key) @protobuf(2,bytes,opt)

	// Cache is the name of the cache that was used
	cacheName: string @go(CacheName) @protobuf(3,bytes,opt)
}

// Cache is the configuration for the type of cache to be used
#Cache: {
	// ConfigMap sets a ConfigMap-based cache
	configMap?: null | apiv1.#ConfigMapKeySelector @go(ConfigMap,*apiv1.ConfigMapKeySelector) @protobuf(1,bytes,opt)
}

#SynchronizationAction: _

#SemaphoreHolding: {
	// Semaphore stores the semaphore name.
	semaphore?: string @go(Semaphore) @protobuf(1,bytes,opt)

	// Holders stores the list of current holder names in the workflow.
	// +listType=atomic
	holders?: [...string] @go(Holders,[]string) @protobuf(2,bytes,opt)
}

#SemaphoreStatus: {
	// Holding stores the list of resource acquired synchronization lock for workflows.
	holding?: [...#SemaphoreHolding] @go(Holding,[]SemaphoreHolding) @protobuf(1,bytes,opt)

	// Waiting indicates the list of current synchronization lock holders.
	waiting?: [...#SemaphoreHolding] @go(Waiting,[]SemaphoreHolding) @protobuf(2,bytes,opt)
}

// MutexHolding describes the mutex and the object which is holding it.
#MutexHolding: {
	// Reference for the mutex
	// e.g: ${namespace}/mutex/${mutexName}
	mutex?: string @go(Mutex) @protobuf(1,bytes,opt)

	// Holder is a reference to the object which holds the Mutex.
	// Holding Scenario:
	//   1. Current workflow's NodeID which is holding the lock.
	//      e.g: ${NodeID}
	// Waiting Scenario:
	//   1. Current workflow or other workflow NodeID which is holding the lock.
	//      e.g: ${WorkflowName}/${NodeID}
	holder?: string @go(Holder) @protobuf(2,bytes,opt)
}

// MutexStatus contains which objects hold  mutex locks, and which objects this workflow is waiting on to release locks.
#MutexStatus: {
	// Holding is a list of mutexes and their respective objects that are held by mutex lock for this workflow.
	// +listType=atomic
	holding?: [...#MutexHolding] @go(Holding,[]MutexHolding) @protobuf(1,bytes,opt)

	// Waiting is a list of mutexes and their respective objects this workflow is waiting for.
	// +listType=atomic
	waiting?: [...#MutexHolding] @go(Waiting,[]MutexHolding) @protobuf(2,bytes,opt)
}

// SynchronizationStatus stores the status of semaphore and mutex.
#SynchronizationStatus: {
	// Semaphore stores this workflow's Semaphore holder details
	semaphore?: null | #SemaphoreStatus @go(Semaphore,*SemaphoreStatus) @protobuf(1,bytes,opt)

	// Mutex stores this workflow's mutex holder details
	mutex?: null | #MutexStatus @go(Mutex,*MutexStatus) @protobuf(2,bytes,opt)
}

// NodeSynchronizationStatus stores the status of a node
#NodeSynchronizationStatus: {
	// Waiting is the name of the lock that this node is waiting for
	waiting?: string @go(Waiting) @protobuf(1,bytes,opt)
}
